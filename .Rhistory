rm(list = ls())
graphics.off()
source("0_libraryPoly.R")
rm(list = ls())
graphics.off()
source("0_libraryPoly.R")
# Remove all existing environment and plots
rm(list = ls())
graphics.off()
source("0_libraryPoly.R")
# This script records all the global variables, functions and libraries
#The working folder with scripts and data
# testing
setwd("/Users/jeremywang/Documents/GitHub/Sensitivity_SRedits_Final")
# Load the required functions and packages
source("sobol_indices_boot.R")
#source("sib_simplified.R")
library(GPfit)
library(lhs)
library(BASS)
# The dimensions we consider
D <- c(2,5,10,15,20,30)
# The list of sample sizes we consider
tot_size <- c(seq(100,1000,by=100),seq(1250,5e3,by=250),seq(6e3,5e4,by=1e3), #original
seq(5.2e4,1.5e5,by=2.5e3),seq(1.55e5,3e5,by=5e3),
seq(3e5,5e5,by=1e4))
# The root folder that saves all the data during code running
folderpath <- "./Ranking_Data/"
# Choose the test model, the number can only be 1 (G function), 2 (Hymod) or 3 (Sacsma)
Testmodel_ind <- 0
# Test comment
if (Testmodel_ind == 0) {# polynomial function
Testmodel<-function (X) {
S = 0
## d is a numerical value selected from numeric D
for (i in 1:d){
if (i%%3==1){
a = i
b = X[i]
} else if (i%%3==2){
a = i
b = X[i]^2*X[i-1]
} else {
a = i
b = X[i]
}
S = S + a*b
}
return(S)
}
}
if (Testmodel_ind == 1){ # G function
Testmodel<-function (X) {
a = rep(NA,d)
for (i in 1:d){
a[i] <- i
}
up <- abs(4*X-2) + a
down <- 1 + a
prod <- prod(up/down)
return(prod)
}
}
if (Testmodel_ind == 2){ # Hymod
source("Hymod.R")
load("arnosubbiano.rda")
Testmodel <- hymodr
D <- 5
## Catchment area [km^2]
area<-751
## Precipitation [mm/day]
precipit<-arnosubbiano[ ,2]
## Potential arnosubbiano [mm/day]
evapo<-arnosubbiano[ ,3]
## Q observation
Q_obs <- arnosubbiano[ ,4]
Range <- matrix(data = c(70,400,0,0.95,0,0.9,0,0.1,0.1,1),nrow = 2,ncol = 5,byrow = FALSE)
}
if (Testmodel_ind == 3){ # SacSma
source("sacSma.R")
load("SacSma_dataframe")
Testmodel <- sacSma
D <- 16
## Precipitation [mm/day]
precipit<-SacSma_dataframe$precipit
## Potential arnosubbiano [mm/day]
evapo<-SacSma_dataframe$evapo
## Q observation
Q_obs <- SacSma_dataframe$Q_obs
Range <- matrix(data = c(5,300,5,150,10,700,100,1200,
5,500,0.1,0.75,0.001,0.05,0.01,0.6,
5,350,1,5,0,0.9,0,0.1,
0,0.4,0.3,0.3,0,0,0,0),nrow = 2,ncol = 16,byrow = FALSE)
known_pars<- c(0.3,0,0)
}
# A function that maps [0,1] to any input range
Mapping <- function (X, Range){
# Range is a matrix with 2 rows (min and max)
if (dim(Range)[2]!=dim(X)[2]){
return("The input dimensions must match")
}
for (i in 1:dim(X)[2]){
X[ ,i] <- Range[1,i] + X[ ,i]*(Range[2,i]-Range[1,i])
}
return(X)
}
#Kriging function, used when calling the emulator in the Sobol analysis
Kriging <- function (X){
a <- predict(GPmodel,X)
a$Y_hat
}
nboot=100
rm(list = ls())
graphics.off()
source("0_libraryPoly.R")
print("4_AKMCS4_diffseeds.R")
# Sobol based on the Adaptive Kriging combined with Monte Carlo Sampling (AKMCS) method
# Note: This script also takes an extremely long time when dealing with high-dimensional
#       models. Again change the dimension vector D for code replication check.
# Remove all existing environment and plots
rm(list = ls())
graphics.off()
source("0_libraryPoly.R")
print("4_AKMCS4_diffseeds.R")
# #necessary packages for parallelization
# library("foreach")
# library("doParallel")
#
# #setup parallel backend to use many processors
# cores=detectCores()
# cl <- makeCluster(cores[1]-1) # -1 not to overload system
# registerDoParallel(cl)
#
# #foreach executes the code within the brackets separately on each node
# foreach(node = 1:4)%dopar%{
source("0_libraryPoly.R")
# Define the test model in each dimension, apply AKMCS and perform the Sobol analysis
k=4
seed<- 4
set.seed(seed)
T_AKMCS<- vector()
T_pred_AKMCS<- vector()
T_AKMCSSobol<- vector()
T_check_AKMCS<- vector()
T_model_AKMCS<- vector()
# model dimension
d <- D[k]
folder<-paste0(folderpath,d,"D/AKMCS/seed",seed) #set folder depending on both d and node
if (!dir.exists(folder)) dir.create(folder, recursive = TRUE)
# Start recording the time from AKMCS initial state
# AKMCS also begins with 20,000 training samples
start.time <- Sys.time()
candidate_size <- 20000
X <- randomLHS(candidate_size,d)
# Save these training samples
save(X,file = paste0(folder,"/initial_sample"))
# Begin with 12 random samples from these training samples
n_init <- 10 + d
indx <- sample(candidate_size,n_init)
AKMCS_size_vec<- n_init
AKMCS_size<- n_init
# Update the used samples and remaining samples
x <- X[indx, ]
x_rest <- X[-indx, ]
# Evaluate model outputs and fit a Kriging model
start.time<- Sys.time()
y <- apply(x,1,Testmodel)
end.time<- Sys.time()
model_time<- difftime(end.time,start.time,units = "secs")
T_model_AKMCS<- c(T_model_AKMCS,model_time)
start.time<- Sys.time()
GPmodel <- GP_fit(x, y)
end.time<- Sys.time()
fit_time<- difftime(end.time,start.time,units = "secs")
T_AKMCS<- c(T_AKMCS,fit_time)
start.time<- Sys.time()
a <- predict(GPmodel,x_rest)
end.time<- Sys.time()
pred_time<- difftime(end.time,start.time,units = "secs")
T_pred_AKMCS<- c(T_pred_AKMCS,pred_time)
# U is the learning function, which is simply the standard error here
U <- sqrt(a$MSE)
print(paste0("sample size =",dim(x)[1], "max(U) =",max(U),"range = ",(max(a$Y_hat)-min(a$Y_hat))/20))
# End the loop if the stopping criterion is fulfilled
# Stopping criterion: all the remaining samples have standard errors larger than 1
# If the criterion is not reached, pick the next sample adaptively based on the learning function
if (max(U)>(max(a$Y_hat)-min(a$Y_hat))/20){
while (1>0){
# Find which sample has the largest standard error
m <- which(U==max(U))
if (length(m)>1){
m <- sample(m,1)
}
# Add that sample and update the remaining samples
x_add <- x_rest[m, ]
x_rest <- x_rest[-m, ]
# Evaluate the output of that sample and update
start.time<- Sys.time()
y_add <- Testmodel(x_add)
end.time<- Sys.time()
model_time<- difftime(end.time,start.time,units = "secs")
T_model_AKMCS<- c(T_model_AKMCS,model_time)
y <- append(y,y_add)
x <- rbind(x,x_add)
# Fit the Kriging model again
start.time<- Sys.time()
GPmodel <- GP_fit(x, y)
end.time <- Sys.time()
fit_time <- difftime(end.time,start.time, units = "secs")
T_AKMCS<- c(T_AKMCS,fit_time)
start.time<- Sys.time()
a <- predict(GPmodel,x_rest)
end.time <- Sys.time()
pred_time <- difftime(end.time,start.time, units = "secs")
T_pred_AKMCS<- c(T_pred_AKMCS,pred_time)
# Get the learning function again
U <- sqrt(a$MSE)
print(paste0("sample size =",dim(x)[1], "max(U) =",max(U),"range = ",(max(a$Y_hat)-min(a$Y_hat))/20))
AKMCS_size<- AKMCS_size+1
AKMCS_size_vec<- c(AKMCS_size_vec,AKMCS_size)
save(AKMCS_size,file = paste0(folder,"/AKMCS_size"))
save(AKMCS_size_vec,file = paste0(folder,"/AKMCS_size_vec"))
save(T_AKMCS,file = paste0(folder,"/T_AKMCS"))
save(T_model_AKMCS,file = paste0(folder,"/T_model_AKMCS"))
save(T_pred_AKMCS,file = paste0(folder,"/T_pred_AKMCS"))
save(x,file = paste0(folder,"/x"))
save(a,file = paste0(folder,"/a"))
# End the loop if the stopping criterion is fulfilled
if (max(U)<(max(a$Y_hat)-min(a$Y_hat))/20){
break
}
}
}
T_AKMCSSobol<- vector()
T_check_AKMCS<- vector()
for (m in 1:length(tot_size)){
# Next perform the sensitivity analysis
N <- floor(tot_size[m]/(d+2+d*(d-1)/2))
if (N>=2) {
Sobol_AKMCS_convergesize<- tot_size[m]
print(paste0("checking convergence of input ranking at a sample size of ", tot_size[m]))
# Time for sensitivity analysis
start.time <- Sys.time()
mat <- sobol_matrices(N = N, params = as.character(c(1:d)), order = "second")
Y_S <- Kriging(mat)
S_AKMCS <- sobol_indices_boot(Y=Y_S,N=N,params = as.character(c(1:d)),
boot=TRUE,R=nboot,order="second")
end.time<-Sys.time()
time_sobol<- difftime(end.time,start.time,units = "secs")
T_AKMCSSobol<-c(T_AKMCSSobol,time_sobol)
# convergence of ranking:
start.time <- Sys.time()
Sens <- S_AKMCS$boot$t[ ,c((1+d):(2*d))]
Rank <- t(apply(Sens, 1, rank))
for (boot_ind1 in 1:(nboot-1)){
T <- boot_ind1
for (boot_ind2 in (T+1):nboot){
Rho <- rep(NA,d)
Weights <- rep(NA,d)
for (para_ind in 1:d){
Weights[para_ind] <- (max(Sens[boot_ind1,para_ind],max(Sens[boot_ind2,para_ind])))^2
}
Weights_sum <- sum(Weights)
for (para_ind in 1:d){
Rho[para_ind] <- abs(Rank[boot_ind1,para_ind]-Rank[boot_ind2,para_ind])*
Weights[para_ind]/Weights_sum
}
if (boot_ind2 == 2){
Rho_all <- Rho
} else{
Rho_all <- append(Rho_all,Rho)
}
}
}
Rho_all <- matrix(Rho_all, nrow = d)
Rho_all <- apply(Rho_all, 2, sum)
end.time <- Sys.time()
time_check <- difftime(end.time,start.time,units = "secs")
T_check_AKMCS<- c(T_check_AKMCS,time_check)
save(T_AKMCSSobol,file = paste0(folder,"/T_AKMCSSobol"))
save(T_check_AKMCS,file=paste0(folder,"/T_check_AKMCS"))
save(S_AKMCS,file=paste0(folder,"/S_AKMCS"))
save(Sobol_AKMCS_convergesize,file=paste0(folder,"/Sobol_AKMCS_convergesize"))
if (!any(is.na(Rho_all))){
#print(quantile(Rho_all,probs = 0.95, na.rm = TRUE))
if (quantile(Rho_all,probs = 0.95, na.rm = TRUE) < 1){
break
}
}
}
}
tot_size
length(tot_size)
tot_size(3)
tot_size[3]
m = 3
Sobol_AKMCS_convergesize<- tot_size[m]
print(paste0("checking convergence of input ranking at a sample size of ", tot_size[m]))
start.time <- Sys.time()
mat <- sobol_matrices(N = N, params = as.character(c(1:d)), order = "second")
Y_S <- Kriging(mat)
S_AKMCS <- sobol_indices_boot(Y=Y_S,N=N,params = as.character(c(1:d)),
boot=TRUE,R=nboot,order="second")
Y_S <- Kriging(mat)
S_AKMCS <- sobol_indices_boot(Y=Y_S,N=N,params = as.character(c(1:d)),
boot=TRUE,R=nboot,order="second")
m = 4
Sobol_AKMCS_convergesize<- tot_size[m]
print(paste0("checking convergence of input ranking at a sample size of ", tot_size[m]))
# Time for sensitivity analysis
start.time <- Sys.time()
mat <- sobol_matrices(N = N, params = as.character(c(1:d)), order = "second")
Y_S <- Kriging(mat)
S_AKMCS <- sobol_indices_boot(Y=Y_S,N=N,params = as.character(c(1:d)),
boot=TRUE,R=nboot,order="second")
# Sobol based on the Adaptive Kriging combined with Monte Carlo Sampling (AKMCS) method
# Note: This script also takes an extremely long time when dealing with high-dimensional
#       models. Again change the dimension vector D for code replication check.
# Remove all existing environment and plots
rm(list = ls())
graphics.off()
source("0_libraryPoly.R")
print("4_AKMCS4_diffseeds.R")
# #necessary packages for parallelization
# library("foreach")
# library("doParallel")
#
# #setup parallel backend to use many processors
# cores=detectCores()
# cl <- makeCluster(cores[1]-1) # -1 not to overload system
# registerDoParallel(cl)
#
# #foreach executes the code within the brackets separately on each node
# foreach(node = 1:4)%dopar%{
source("0_libraryPoly.R")
# Define the test model in each dimension, apply AKMCS and perform the Sobol analysis
k=4
seed<- 5
set.seed(seed)
T_AKMCS<- vector()
T_pred_AKMCS<- vector()
T_AKMCSSobol<- vector()
T_check_AKMCS<- vector()
T_model_AKMCS<- vector()
# model dimension
d <- D[k]
folder<-paste0(folderpath,d,"D/AKMCS/seed",seed) #set folder depending on both d and node
if (!dir.exists(folder)) dir.create(folder, recursive = TRUE)
# Start recording the time from AKMCS initial state
# AKMCS also begins with 20,000 training samples
start.time <- Sys.time()
candidate_size <- 20000
X <- randomLHS(candidate_size,d)
# Save these training samples
save(X,file = paste0(folder,"/initial_sample"))
# Begin with 12 random samples from these training samples
n_init <- 10 + d
indx <- sample(candidate_size,n_init)
AKMCS_size_vec<- n_init
AKMCS_size<- n_init
# Update the used samples and remaining samples
x <- X[indx, ]
x_rest <- X[-indx, ]
# Evaluate model outputs and fit a Kriging model
start.time<- Sys.time()
y <- apply(x,1,Testmodel)
end.time<- Sys.time()
model_time<- difftime(end.time,start.time,units = "secs")
T_model_AKMCS<- c(T_model_AKMCS,model_time)
start.time<- Sys.time()
GPmodel <- GP_fit(x, y)
end.time<- Sys.time()
fit_time<- difftime(end.time,start.time,units = "secs")
T_AKMCS<- c(T_AKMCS,fit_time)
start.time<- Sys.time()
a <- predict(GPmodel,x_rest)
end.time<- Sys.time()
pred_time<- difftime(end.time,start.time,units = "secs")
T_pred_AKMCS<- c(T_pred_AKMCS,pred_time)
# U is the learning function, which is simply the standard error here
U <- sqrt(a$MSE)
print(paste0("sample size =",dim(x)[1], "max(U) =",max(U),"range = ",(max(a$Y_hat)-min(a$Y_hat))/20))
# End the loop if the stopping criterion is fulfilled
# Stopping criterion: all the remaining samples have standard errors larger than 1
# If the criterion is not reached, pick the next sample adaptively based on the learning function
if (max(U)>(max(a$Y_hat)-min(a$Y_hat))/20){
while (1>0){
# Find which sample has the largest standard error
m <- which(U==max(U))
if (length(m)>1){
m <- sample(m,1)
}
# Add that sample and update the remaining samples
x_add <- x_rest[m, ]
x_rest <- x_rest[-m, ]
# Evaluate the output of that sample and update
start.time<- Sys.time()
y_add <- Testmodel(x_add)
end.time<- Sys.time()
model_time<- difftime(end.time,start.time,units = "secs")
T_model_AKMCS<- c(T_model_AKMCS,model_time)
y <- append(y,y_add)
x <- rbind(x,x_add)
# Fit the Kriging model again
start.time<- Sys.time()
GPmodel <- GP_fit(x, y)
end.time <- Sys.time()
fit_time <- difftime(end.time,start.time, units = "secs")
T_AKMCS<- c(T_AKMCS,fit_time)
start.time<- Sys.time()
a <- predict(GPmodel,x_rest)
end.time <- Sys.time()
pred_time <- difftime(end.time,start.time, units = "secs")
T_pred_AKMCS<- c(T_pred_AKMCS,pred_time)
# Get the learning function again
U <- sqrt(a$MSE)
print(paste0("sample size =",dim(x)[1], "max(U) =",max(U),"range = ",(max(a$Y_hat)-min(a$Y_hat))/20))
AKMCS_size<- AKMCS_size+1
AKMCS_size_vec<- c(AKMCS_size_vec,AKMCS_size)
save(AKMCS_size,file = paste0(folder,"/AKMCS_size"))
save(AKMCS_size_vec,file = paste0(folder,"/AKMCS_size_vec"))
save(T_AKMCS,file = paste0(folder,"/T_AKMCS"))
save(T_model_AKMCS,file = paste0(folder,"/T_model_AKMCS"))
save(T_pred_AKMCS,file = paste0(folder,"/T_pred_AKMCS"))
save(x,file = paste0(folder,"/x"))
save(a,file = paste0(folder,"/a"))
# End the loop if the stopping criterion is fulfilled
if (max(U)<(max(a$Y_hat)-min(a$Y_hat))/20){
break
}
}
}
T_AKMCSSobol<- vector()
T_check_AKMCS<- vector()
for (m in 1:length(tot_size)){
# Next perform the sensitivity analysis
N <- floor(tot_size[m]/(d+2+d*(d-1)/2))
if (N>=2) {
Sobol_AKMCS_convergesize<- tot_size[m]
print(paste0("checking convergence of input ranking at a sample size of ", tot_size[m]))
# Time for sensitivity analysis
start.time <- Sys.time()
mat <- sobol_matrices(N = N, params = as.character(c(1:d)), order = "second")
Y_S <- Kriging(mat)
S_AKMCS <- sobol_indices_boot(Y=Y_S,N=N,params = as.character(c(1:d)),
boot=TRUE,R=nboot,order="second")
end.time<-Sys.time()
time_sobol<- difftime(end.time,start.time,units = "secs")
T_AKMCSSobol<-c(T_AKMCSSobol,time_sobol)
# convergence of ranking:
start.time <- Sys.time()
Sens <- S_AKMCS$boot$t[ ,c((1+d):(2*d))]
Rank <- t(apply(Sens, 1, rank))
for (boot_ind1 in 1:(nboot-1)){
T <- boot_ind1
for (boot_ind2 in (T+1):nboot){
Rho <- rep(NA,d)
Weights <- rep(NA,d)
for (para_ind in 1:d){
Weights[para_ind] <- (max(Sens[boot_ind1,para_ind],max(Sens[boot_ind2,para_ind])))^2
}
Weights_sum <- sum(Weights)
for (para_ind in 1:d){
Rho[para_ind] <- abs(Rank[boot_ind1,para_ind]-Rank[boot_ind2,para_ind])*
Weights[para_ind]/Weights_sum
}
if (boot_ind2 == 2){
Rho_all <- Rho
} else{
Rho_all <- append(Rho_all,Rho)
}
}
}
Rho_all <- matrix(Rho_all, nrow = d)
Rho_all <- apply(Rho_all, 2, sum)
end.time <- Sys.time()
time_check <- difftime(end.time,start.time,units = "secs")
T_check_AKMCS<- c(T_check_AKMCS,time_check)
save(T_AKMCSSobol,file = paste0(folder,"/T_AKMCSSobol"))
save(T_check_AKMCS,file=paste0(folder,"/T_check_AKMCS"))
save(S_AKMCS,file=paste0(folder,"/S_AKMCS"))
save(Sobol_AKMCS_convergesize,file=paste0(folder,"/Sobol_AKMCS_convergesize"))
if (!any(is.na(Rho_all))){
#print(quantile(Rho_all,probs = 0.95, na.rm = TRUE))
if (quantile(Rho_all,probs = 0.95, na.rm = TRUE) < 1){
break
}
}
}
}
# }
